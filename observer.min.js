class Observer{constructor(objects,namespaces,functions,blacklist){this.objects=objects,this.namespaces=namespaces,this.functions=functions,this.blacklist=blacklist,this.blacklist=new Array(...new Set([...this.blacklist,"toString","setInterval","setTimeout","clearInterval","fetch"]))}augment(object,functionName,aspect,advice){const original=object[functionName];object[functionName]=function(){["before","around"].indexOf(advice)>-1&&aspect.apply(object,[original,functionName,[...arguments]]);const returnValue=original.apply(this,[...arguments]);return["after","around"].indexOf(advice)>-1&&aspect.apply(object,[original,functionName,[...arguments]]),"afterReturning"===advice?aspect.apply(object,[returnValue]):returnValue}}injectObject(object,functions){for(var name in object)if("[object Function]"===Object.prototype.toString.call(object[name])&&-1===this.blacklist.indexOf(object[name].name))for(let _function of functions)this.augment(object,name,_function.aspect,_function.advice)}startObserver(){for(let _object of this.objects)this.injectObject(_object.prototype,this.functions);for(let _namespace of this.namespaces)this.injectObject(_namespace,this.functions)}}