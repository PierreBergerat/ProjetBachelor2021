class Observer{constructor(t,e,s,i){this.objects=t,this.namespaces=e,this.functions=s,this.blacklist=i,this.blacklist=new Array(...new Set([...this.blacklist,"toString","setInterval","setTimeout","clearInterval","fetch"]))}augment(t,e,s,i){const n=t[e];t[e]=function(){["before","around"].indexOf(i)>-1&&s.apply(t,[n,e,[...arguments]]);const c=n.apply(this,[...arguments]);return["after","around"].indexOf(i)>-1&&s.apply(t,[n,e,[...arguments]]),"afterReturning"===i?s.apply(t,[c]):c}}injectObject(t,e){for(var s in t)if("[object Function]"===Object.prototype.toString.call(t[s])&&-1===this.blacklist.indexOf(t[s].name))for(let i of e)this.augment(t,s,i.aspect,i.advice)}startObserver(){for(let t of this.objects)this.injectObject(t.prototype,this.functions);for(let t of this.namespaces)this.injectObject(t,this.functions)}}